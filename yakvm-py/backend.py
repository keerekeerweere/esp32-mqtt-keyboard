import os
import logging
from flask import Flask, request, jsonify
import paho.mqtt.client as mqtt
from keyevent_pb2 import ProtoKeyEvent  # Generated by protoc
from dotenv import load_dotenv

# Logging setup
logging.basicConfig(filename='yakvm-app.log', level=logging.INFO, format='[%(asctime)s] %(message)s')

load_dotenv()  # This loads variables from .env into os.environ


app = Flask(__name__)

# Modifier masks
# Modifier masks: (LEFT, RIGHT)
MOD_NONE             = 0
MOD_LEFT_CTRL       = 1 <<  8
MOD_LEFT_SHIFT      = 1 <<  9
MOD_LEFT_ALT        = 1 << 10
MOD_LEFT_GUI        = 1 << 11
MOD_RIGHT_CTRL      = 1 << 12
MOD_RIGHT_SHIFT     = 1 << 13
MOD_RIGHT_ALT       = 1 << 14
MOD_RIGHT_GUI       = 1 << 15

# MQTT setup
MQTT_PROTOCOL = os.getenv("MQTT_PROTOCOL", "mqtt")
MQTT_HOST = os.getenv("MQTT_HOST", "localhost")
MQTT_PORT = int(os.getenv("MQTT_PORT", "443"))
MQTT_PATH = os.getenv("MQTT_PATH", "")
MQTT_USERNAME = os.getenv("MQTT_USERNAME")
MQTT_PASSWORD = os.getenv("MQTT_PASSWORD")

clientId = "yakvm-python-backend"

# MQTT client setup
if MQTT_PROTOCOL in ["ws", "wss"]:
    client = mqtt.Client(transport="websockets", client_id=clientId)
else:
    client = mqtt.Client(client_id=clientId)

if MQTT_USERNAME:
    client.username_pw_set(MQTT_USERNAME, MQTT_PASSWORD)

if MQTT_PROTOCOL in ["mqtts", "wss"]:
    client.tls_set()

# DO NOT pass path=... unless using websockets
if MQTT_PROTOCOL in ["ws", "wss"] and MQTT_PATH:
    client.ws_set_options(path=MQTT_PATH)

client.username_pw_set(MQTT_USERNAME, MQTT_PASSWORD)


def on_connect(client, userdata, flags, rc):
    logging.info(f"✅ MQTT connected with result code {rc}")

def on_error(client, userdata, rc):
    logging.error(f"❌ MQTT error: {rc}")

client.on_connect = on_connect
client.connect(MQTT_HOST, MQTT_PORT, 60)
client.loop_start()

@app.route('/keypress', methods=['POST'])
def keypress():
    data = request.get_json()
    key = data.get('key')
    location = data.get('location')

    if not key or not isinstance(location, int):
        return jsonify({'error': 'Missing or invalid key or location'}), 400

    mod = MOD_NONE
    if data.get('ctrlKey'):
        mod |= MOD_RIGHT_CTRL if location == 2 else MOD_LEFT_CTRL
    if data.get('shiftKey'):
        mod |= MOD_RIGHT_SHIFT if location == 2 else MOD_LEFT_SHIFT
    if data.get('altKey'):
        mod |= MOD_RIGHT_ALT if location == 2 else MOD_LEFT_ALT
    if data.get('metaKey'):
        mod |= MOD_RIGHT_GUI if location == 2 else MOD_LEFT_GUI


    payload = ProtoKeyEvent(
        modifier=mod,
        functionkey=key if len(key) >= 1 else "",
        sendstring=""  # explicitly set even if empty
    )

    topic = "esphid1/cmnd/FUNCTION" if len(key) > 1 else "esphid1/cmnd/WRITE"

    buffer = payload.SerializeToString()

    print("Serialized bytes to publish:", list(buffer))
    try:
        client.publish(topic, buffer)
        logging.info(f"Published to {topic}: mod={mod} key={key}")
        return jsonify({'status': 'Published', 'mod': mod, 'key': key})
    except Exception as e:
        logging.error(f"Failed to publish to {topic}: {e}")
        return jsonify({'error': 'MQTT publish failed'}), 500

if __name__ == '__main__':
    app.run(port=3000)
